/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.trino.plugin.postgresql;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Sets;
import io.airlift.configuration.Config;
import io.airlift.configuration.ConfigSecuritySensitive;
import io.github.classgraph.AnnotationInfo;
import io.github.classgraph.AnnotationParameterValueList;
import io.github.classgraph.ClassGraph;
import io.github.classgraph.ScanResult;
import io.trino.spi.Plugin;
import io.trino.spi.connector.ConnectorFactory;
import io.trino.testing.TestingConnectorContext;
import org.junit.jupiter.api.Test;

import java.io.IOException;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Set;

import static com.google.common.base.Preconditions.checkState;
import static com.google.common.collect.ImmutableSet.toImmutableSet;
import static com.google.common.collect.Iterables.getOnlyElement;
import static org.assertj.core.api.Assertions.assertThat;

public class TestPostgreSqlPlugin
{
    @Test
    public void testCreateConnector()
    {
        Plugin plugin = new PostgreSqlPlugin();
        ConnectorFactory factory = getOnlyElement(plugin.getConnectorFactories());
        factory.create(
                "test",
                ImmutableMap.of(
                        "connection-url", "jdbc:postgresql:test",
                        "bootstrap.quiet", "true"),
                new TestingConnectorContext()).shutdown();
    }

    @Test
    void testConnectorSensitivePropertyNameSetIsComplete()
            throws Exception
    {
        // The purpose of this test is to help identify security-sensitive properties that
        // may be used by the connector. These properties are detected by scanning the
        // plugin's runtime classpath and collecting all property names annotated with
        // @ConfigSecuritySensitive. The scan includes all configuration classes, whether
        // they are always used, conditionally used, or never used. This approach has both
        // advantages and disadvantages.
        //
        // One advantage is that we don't need to rely on the plugin's configuration to
        // retrieve properties that are used conditionally. However, this method may also
        // capture properties that are not used at all but are pulled into the classpath
        // by dependencies. With that in mind, if this test fails, it likely indicates that
        // either a property needs to be added to the connector's security-sensitive
        // property names list, or it should be added to the excluded properties list below.
        Set<String> excludedProperties = ImmutableSet.of(
                "http-client.https.automatic-shared-secret",
                "http-client.key-store-password",
                "http-client.trust-store-password",
                "ldap.ssl.keystore.password",
                "ldap.ssl.truststore.password");
        Plugin plugin = new PostgreSqlPlugin();
        ConnectorFactory connectorFactory = getOnlyElement(plugin.getConnectorFactories());

        Set<String> actualProperties = connectorFactory.getSecuritySensitivePropertyNames();
        Set<String> propertiesFoundInClasspath = findSensitivePropertiesInRuntimeClasspath();
        Set<String> expectedProperties = Sets.difference(propertiesFoundInClasspath, excludedProperties);

        assertThat(actualProperties).isEqualTo(expectedProperties);
        // Verify that the expectedProperties set contains only properties that exist and are marked as security-sensitive.
        assertThat(propertiesFoundInClasspath).containsAll(excludedProperties);
    }

    private static Set<String> findSensitivePropertiesInRuntimeClasspath()
            throws URISyntaxException, IOException
    {
        // This file is generated by the maven-dependency-plugin, which is configured in the connector's pom.xml file.
        String runtimeClasspathFile = "runtime-classpath.txt";
        URL runtimeClasspathUrl = TestPostgreSqlPlugin.class.getClassLoader().getResource(runtimeClasspathFile);
        checkState(runtimeClasspathUrl != null, "Missing %s file", runtimeClasspathFile);
        String runtimeClasspath = Files.readString(Path.of(runtimeClasspathUrl.toURI()));

        try (ScanResult scanResult = new ClassGraph()
                .overrideClasspath(runtimeClasspath)
                .enableAllInfo()
                .scan()) {
            return scanResult.getClassesWithMethodAnnotation(ConfigSecuritySensitive.class).stream()
                    .flatMap(classInfo -> classInfo.getMethodInfo().stream())
                    .filter(methodInfo -> methodInfo.hasAnnotation(ConfigSecuritySensitive.class))
                    .map(methodInfo -> {
                        AnnotationInfo annotationInfo = methodInfo.getAnnotationInfo(Config.class);
                        checkState(annotationInfo != null, "Missing @Config annotation for %s", methodInfo);
                        AnnotationParameterValueList parameterValues = annotationInfo.getParameterValues();
                        checkState(parameterValues.size() == 1, "Expected exactly one parameter for %s", annotationInfo);
                        return (String) parameterValues.getFirst().getValue();
                    })
                    .collect(toImmutableSet());
        }
    }
}
